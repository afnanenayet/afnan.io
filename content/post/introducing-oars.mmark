---
title: "Introducing oars"
description: "A Rust library for handling orthogonal arrays"
date: 2019-06-14T21:47:21-04:00
tags: ["orthogonal", "array", "rust", "library", "monte", "carlo"]
draft: true
---

## The Motivation Behind `oars`

For a while now, I have been working on a library called `oars` (*o*rthogonal
*a*rrays *r*u*s*t).

The need for this library was born out of the work we were doing on my senior
thesis and related EGSR paper. The team and I were working on implementing
orthogonal array construction methods, and using Art Owen's techniques to
create point sets from these orthogonal arrays that are suitable for Monte
Carlo integration. At first, we implemented these algorithms and generation
methods and relied on code review and visualizations to ensure that these
points were correct (i.e. valid orthogonal arrays). As I attempted to implement
more complex methods, I found that I was having a more difficult time catching
small errors, and that I was having a tough time verifying my work in general.
I decided to go ahead and create something new that would hopefully help me
with my work, and be a little more conducive to my workflow.

## Orthogonal Arrays

You may be wondering what an orthogonal array (OA) actually is. For an in-depth
read, check out my [thesis](/documents/undergrad_thesis.pdf). In this post,
I'll give a broader overview.

## Development

The API design for `oars` was heavily inspired by the work that my advisor,
Wojciech Jarosz, did with his tool SampleView. I liked the way his API was
designed - it made sense and it was clean. I simplified the generic API for
orthogonal arrays a little bit, since simplified the generic API for orthogonal
arrays a little bit, since `oars` isn't a general purpose Monte Carlo sampling
library, but specifically geared towards orthogonal arrays.

One of Rust's strong points is its type system and extensive used of generics.
I wanted my library to be as generic as possible, so I didn't tie my APIs to
any particular numeric type. If you have done any heavy numeric work in Rust,
you know how much of a pain this can be. I used the
[num](https://github.com/rust-num/num) crate to help facilitate numeric generic
traits, but even then, I found the process to be lacking in ergonomics.

Consider the following code snippet in C++:

```cpp
<typename T>
T add_one(T x) {
    return x + 1;
}
```

Now compare this to Rust:

```rust
// We need to use the num crate to have generic methods over numeric types
use num::{NumCast, FromPrimitive};

fn add_one<T>(x: T)
where T: NumCast + FromPrimitive + Copy
{
    x + T::from(1).unwrap()
}
```

While this is a smaller example, we can already see that the Rust code snippet
is much more verbose. My codebase is littered with a lot of these calls, which
can be slightly annoying. I understand why Rust has these safeguards in place,
as there are many small overflow and loss of precision errors that can happen
when C++ engages in reckless implicit casting. I've been a victim of these
errors myself, even in this project. All the same, I wonder if there is a more
ergonomic way we could handle numeric types in Rust and reduce some of the
boilerplate.

There are a lot of features that Rust has that made development much more
ergonomic than if I had written this library in C++. The biggest pain point I
have with C++ development is handling libraries. I prefer to use system
libraries whenever I can, since I'm on Arch and I can easily install pretty
much every library I'll ever need, but a lot of times when I'm collaborating
with people on different platforms, we have to use other solutions, like
bundling dependencies in tree, or use something like [Conan](https://conan.io)
or [vcpkg](https://github.com/microsoft/vcpkg). While both managers are really
nice, I have issues with both of them, and not everyone always has them
available. More often than not, we simply bundle dependencies as git
submodules.

Rust, on the other hand, has Cargo, which is an excellent package manager. I
really enjoy how easy it is to add a dependency and link it with your project.
Cargo feels much saner than `cmake`, and I don't have to deal with obscure
linker errors. On top of that, Rust's testing and benchmarking tools are really
easy to use, and provide a standardized and ergonomic way to implement testing
and benchmarks. This sort of easy verification helped me a lot in ensuring that
my implementations of various orthogonal array construction techniques were not
only correct, but performant.

## The API

As I mentioned before, the API for this project was heavily inspired by the
SampleView program. For each construction method, I have a struct which holds
parameters that are filled in by the user. There is a trait, `OAConstructor`,
which demarcates structs that can generate orthogonal arrays. This trait
contains only one function: `gen()`, which returns a valid orthogonal array.
Most of the structs that implement this trait will also likely want some sort
of verification method that ensures that the parameters that users pass in are
valid. I didn't create a standardized interface for this because I wanted to
leave some flexibility for the future and for consumers that implement the
`OAConstructor` trait. Additionally, our research on orthogonal arrays is still
fairly early, so I don't actually know what kind of constraints will come up as
we discover new methods for generating orthogonal arrays.
